{"identifier": "addAll", "parameters": "(T[] array1, T... array2)", "modifiers": "public static", "return": "T[]", "body": "public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName(), ase);\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }", "class": "ArrayUtils", "signature": "T[] addAll(T[] array1, T... array2)", "full_signature": "public static T[] addAll(T[] array1, T... array2)", "class_method_signature": "ArrayUtils.addAll(T[] array1, T... array2)", "testcase": false, "constructor": false, "invocations": ["clone", "clone", "getComponentType", "getClass", "newInstance", "arraycopy", "arraycopy", "getComponentType", "getClass", "isAssignableFrom", "getName", "getName"]}