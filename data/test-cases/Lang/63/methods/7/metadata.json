{"identifier": "formatPeriod", "parameters": "(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone)", "modifiers": "public static", "return": "String", "body": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -= 1;\n            end.add(Calendar.MONTH, 1);\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }", "class": "DurationFormatUtils", "signature": "String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone)", "full_signature": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone)", "class_method_signature": "DurationFormatUtils.formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone)", "testcase": false, "constructor": false, "invocations": ["formatDuration", "lexx", "getInstance", "setTime", "getInstance", "setTime", "get", "get", "get", "get", "get", "get", "get", "get", "get", "get", "get", "get", "get", "get", "add", "getActualMaximum", "add", "containsTokenWithValue", "containsTokenWithValue", "containsTokenWithValue", "get", "get", "containsTokenWithValue", "containsTokenWithValue", "containsTokenWithValue", "containsTokenWithValue", "format"]}