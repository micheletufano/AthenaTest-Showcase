{"identifier": "getLevenshteinDistance", "parameters": "(CharSequence s, CharSequence t, int threshold)", "modifiers": "public static", "return": "int", "body": "public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        /*\n        This implementation only computes the distance if it's less than or equal to the\n        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded\n        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only \n        computing a diagonal stripe of width 2k + 1 of the cost table.\n        It is also possible to use this to compute the unbounded Levenshtein distance by starting\n        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where\n        d is the distance.\n        \n        One subtlety comes from needing to ignore entries on the border of our stripe\n        eg.\n        p[] = |#|#|#|*\n        d[] =  *|#|#|#|\n        We must ignore the entry to the left of the leftmost member\n        We must ignore the entry above the rightmost member\n        \n        Another subtlety comes from our stripe running off the matrix if the strings aren't\n        of the same size.  Since string s is always swapped to be the shorter of the two, \n        the stripe will always run off to the upper right instead of the lower left of the matrix.\n        \n        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.\n        In this case we're going to walk a stripe of length 3.  The matrix would look like so:\n        \n           1 2 3 4 5\n        1 |#|#| | | |\n        2 |#|#|#| | |\n        3 | |#|#|#| |\n        4 | | |#|#|#|\n        5 | | | |#|#|\n        6 | | | | |#|\n        7 | | | | | |\n\n        Note how the stripe leads off the table as there is no possible way to turn a string of length 5\n        into one of length 7 in edit distance of 1.\n        \n        Additionally, this implementation decreases memory usage by using two \n        single-dimensional arrays and swapping them back and forth instead of allocating\n        an entire n by m matrix.  This requires a few minor changes, such as immediately returning \n        when it's detected that the stripe has run off the matrix and initially filling the arrays with\n        large values so that entries we don't compute are ignored.\n\n        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n         */\n\n        int n = s.length(); // length of s\n        int m = t.length(); // length of t\n\n        // if one string is empty, the edit distance is necessarily the length of the other\n        if (n == 0) {\n            return m <= threshold ? m : -1;\n        } else if (m == 0) {\n            return n <= threshold ? n : -1;\n        }\n\n        if (n > m) {\n            // swap the two strings to consume less memory\n            CharSequence tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n + 1]; // 'previous' cost array, horizontally\n        int d[] = new int[n + 1]; // cost array, horizontally\n        int _d[]; // placeholder to assist in swapping p and d\n\n        // fill in starting table values\n        int boundary = Math.min(n, threshold) + 1;\n        for (int i = 0; i < boundary; i++) {\n            p[i] = i;\n        }\n        // these fills ensure that the value above the rightmost entry of our \n        // stripe will be ignored in following loop iterations\n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        // iterates through t\n        for (int j = 1; j <= m; j++) {\n            char t_j = t.charAt(j - 1); // jth character of t\n            d[0] = j;\n\n            // compute stripe indices, constrain to array size\n            int min = Math.max(1, j - threshold);\n            int max = Math.min(n, j + threshold);\n\n            // the stripe may lead off of the table if s and t are of different sizes\n            if (min > max) {\n                return -1;\n            }\n\n            // ignore entry left of leftmost\n            if (min > 1) {\n                d[min - 1] = Integer.MAX_VALUE;\n            }\n\n            // iterates through [min, max] in s\n            for (int i = min; i <= max; i++) {\n                if (s.charAt(i - 1) == t_j) {\n                    // diagonally left and up\n                    d[i] = p[i - 1];\n                } else {\n                    // 1 + minimum of cell to the left, to the top, diagonally left and up\n                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n            }\n\n            // copy current distance counts to 'previous row' distance counts\n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        // if p[n] is greater than the threshold, there's no guarantee on it being the correct\n        // distance\n        if (p[n] <= threshold) {\n            return p[n];\n        } else {\n            return -1;\n        }\n    }", "class": "StringUtils", "signature": "int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold)", "full_signature": "public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold)", "class_method_signature": "StringUtils.getLevenshteinDistance(CharSequence s, CharSequence t, int threshold)", "testcase": false, "constructor": false, "invocations": ["length", "length", "length", "min", "fill", "fill", "charAt", "max", "min", "charAt", "min", "min"]}