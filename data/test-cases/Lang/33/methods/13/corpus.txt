ClassUtils { public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) { if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) { return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } } if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) { return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); } ClassUtils(); static String getShortClassName(Object object, String valueIfNull); static String getShortClassName(Class<?> cls); static String getShortClassName(String className); static String getPackageName(Object object, String valueIfNull); static String getPackageName(Class<?> cls); static String getPackageName(String className); static List<Class<?>> getAllSuperclasses(Class<?> cls); static List<Class<?>> getAllInterfaces(Class<?> cls); static List<Class<?>> convertClassNamesToClasses(List<String> classNames); static List<String> convertClassesToClassNames(List<Class<?>> classes); static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray); static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing); static boolean isAssignable(Class<?> cls, Class<?> toClass); static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing); static Class<?> primitiveToWrapper(Class<?> cls); static Class<?>[] primitivesToWrappers(Class<?>[] classes); static Class<?> wrapperToPrimitive(Class<?> cls); static Class<?>[] wrappersToPrimitives(Class<?>[] classes); static boolean isInnerClass(Class<?> cls); static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize); static Class<?> getClass(ClassLoader classLoader, String className); static Class<?> getClass(String className); static Class<?> getClass(String className, boolean initialize); static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]); static Class<?>[] toClass(Object[] array); static String getShortCanonicalName(Object object, String valueIfNull); static String getShortCanonicalName(Class<?> cls); static String getShortCanonicalName(String canonicalName); static String getPackageCanonicalName(Object object, String valueIfNull); static String getPackageCanonicalName(Class<?> cls); static String getPackageCanonicalName(String canonicalName); static final char PACKAGE_SEPARATOR_CHAR; static final String PACKAGE_SEPARATOR; static final char INNER_CLASS_SEPARATOR_CHAR; static final String INNER_CLASS_SEPARATOR; }