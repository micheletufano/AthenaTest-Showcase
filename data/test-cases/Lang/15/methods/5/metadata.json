{"identifier": "normalizeUpperBounds", "parameters": "(Type[] bounds)", "modifiers": "public static", "return": "Type[]", "body": "public static Type[] normalizeUpperBounds(Type[] bounds) {\n        // don't bother if there's only one (or none) type\n        if (bounds.length < 2) {\n            return bounds;\n        }\n\n        Set<Type> types = new HashSet<Type>(bounds.length);\n\n        for (Type type1 : bounds) {\n            boolean subtypeFound = false;\n\n            for (Type type2 : bounds) {\n                if (type1 != type2 && isAssignable(type2, type1, null)) {\n                    subtypeFound = true;\n                    break;\n                }\n            }\n\n            if (!subtypeFound) {\n                types.add(type1);\n            }\n        }\n\n        return types.toArray(new Type[types.size()]);\n    }", "class": "TypeUtils", "signature": "Type[] normalizeUpperBounds(Type[] bounds)", "full_signature": "public static Type[] normalizeUpperBounds(Type[] bounds)", "class_method_signature": "TypeUtils.normalizeUpperBounds(Type[] bounds)", "testcase": false, "constructor": false, "invocations": ["isAssignable", "add", "toArray", "size"]}