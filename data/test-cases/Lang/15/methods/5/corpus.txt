TypeUtils { public static Type[] normalizeUpperBounds(Type[] bounds) { if (bounds.length < 2) { return bounds; } Set<Type> types = new HashSet<Type>(bounds.length); for (Type type1 : bounds) { boolean subtypeFound = false; for (Type type2 : bounds) { if (type1 != type2 && isAssignable(type2, type1, null)) { subtypeFound = true; break; } } if (!subtypeFound) { types.add(type1); } } return types.toArray(new Type[types.size()]); } TypeUtils(); static boolean isAssignable(Type type, Type toType); static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type); static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass); static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls, ParameterizedType superType); static boolean isInstance(Object value, Type type); static Type[] normalizeUpperBounds(Type[] bounds); static Type[] getImplicitBounds(TypeVariable<?> typeVariable); static Type[] getImplicitUpperBounds(WildcardType wildcardType); static Type[] getImplicitLowerBounds(WildcardType wildcardType); static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns); static Class<?> getRawType(Type type, Type assigningType); static boolean isArrayType(Type type); static Type getArrayComponentType(Type type); }