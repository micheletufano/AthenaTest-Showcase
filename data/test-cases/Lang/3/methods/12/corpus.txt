NumberUtils { public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { return createBigInteger(str); } if (hexDigits > 8) { return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; int numDecimals = 0; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); numDecimals = dec.length(); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } final String numeric = str.substring(0, str.length() - 1); final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (final NumberFormatException nfe) { } return createBigInteger(numeric); } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { final Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { } case 'd' : case 'D' : try { final Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { } try { return createBigDecimal(numeric); } catch (final NumberFormatException e) { } default : throw new NumberFormatException(str + " is not a valid number."); } } if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { try { return createInteger(str); } catch (final NumberFormatException nfe) { } try { return createLong(str); } catch (final NumberFormatException nfe) { } return createBigInteger(str); } final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){ final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { } try { if(numDecimals <= 16){ final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } } catch (final NumberFormatException nfe) { } return createBigDecimal(str); } NumberUtils(); static int toInt(final String str); static int toInt(final String str, final int defaultValue); static long toLong(final String str); static long toLong(final String str, final long defaultValue); static float toFloat(final String str); static float toFloat(final String str, final float defaultValue); static double toDouble(final String str); static double toDouble(final String str, final double defaultValue); static byte toByte(final String str); static byte toByte(final String str, final byte defaultValue); static short toShort(final String str); static short toShort(final String str, final short defaultValue); static Number createNumber(final String str); static Float createFloat(final String str); static Double createDouble(final String str); static Integer createInteger(final String str); static Long createLong(final String str); static BigInteger createBigInteger(final String str); static BigDecimal createBigDecimal(final String str); static long min(final long[] array); static int min(final int[] array); static short min(final short[] array); static byte min(final byte[] array); static double min(final double[] array); static float min(final float[] array); static long max(final long[] array); static int max(final int[] array); static short max(final short[] array); static byte max(final byte[] array); static double max(final double[] array); static float max(final float[] array); static long min(long a, final long b, final long c); static int min(int a, final int b, final int c); static short min(short a, final short b, final short c); static byte min(byte a, final byte b, final byte c); static double min(final double a, final double b, final double c); static float min(final float a, final float b, final float c); static long max(long a, final long b, final long c); static int max(int a, final int b, final int c); static short max(short a, final short b, final short c); static byte max(byte a, final byte b, final byte c); static double max(final double a, final double b, final double c); static float max(final float a, final float b, final float c); static boolean isDigits(final String str); static boolean isNumber(final String str); static final Long LONG_ZERO; static final Long LONG_ONE; static final Long LONG_MINUS_ONE; static final Integer INTEGER_ZERO; static final Integer INTEGER_ONE; static final Integer INTEGER_MINUS_ONE; static final Short SHORT_ZERO; static final Short SHORT_ONE; static final Short SHORT_MINUS_ONE; static final Byte BYTE_ZERO; static final Byte BYTE_ONE; static final Byte BYTE_MINUS_ONE; static final Double DOUBLE_ZERO; static final Double DOUBLE_ONE; static final Double DOUBLE_MINUS_ONE; static final Float FLOAT_ZERO; static final Float FLOAT_ONE; static final Float FLOAT_MINUS_ONE; }