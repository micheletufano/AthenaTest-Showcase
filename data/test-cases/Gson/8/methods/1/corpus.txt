UnsafeAllocator { public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName("sun.misc.Unsafe"); Field f = unsafeClass.getDeclaredField("theUnsafe"); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class .getDeclaredMethod("getConstructorId", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class .getDeclaredMethod("newInstance", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class .getDeclaredMethod("newInstance", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException("Cannot allocate " + c); } }; } abstract T newInstance(Class<T> c); static UnsafeAllocator create(); }