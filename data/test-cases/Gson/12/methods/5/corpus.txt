JsonTreeReader extends JsonReader { @Override public JsonToken peek() throws IOException { if (stackSize == 0) { return JsonToken.END_DOCUMENT; } Object o = peekStack(); if (o instanceof Iterator) { boolean isObject = stack[stackSize - 2] instanceof JsonObject; Iterator<?> iterator = (Iterator<?>) o; if (iterator.hasNext()) { if (isObject) { return JsonToken.NAME; } else { push(iterator.next()); return peek(); } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; } } else if (o instanceof JsonObject) { return JsonToken.BEGIN_OBJECT; } else if (o instanceof JsonArray) { return JsonToken.BEGIN_ARRAY; } else if (o instanceof JsonPrimitive) { JsonPrimitive primitive = (JsonPrimitive) o; if (primitive.isString()) { return JsonToken.STRING; } else if (primitive.isBoolean()) { return JsonToken.BOOLEAN; } else if (primitive.isNumber()) { return JsonToken.NUMBER; } else { throw new AssertionError(); } } else if (o instanceof JsonNull) { return JsonToken.NULL; } else if (o == SENTINEL_CLOSED) { throw new IllegalStateException("JsonReader is closed"); } else { throw new AssertionError(); } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }