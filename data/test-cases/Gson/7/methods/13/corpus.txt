JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected a long but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected a long but was " + peekedString + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }