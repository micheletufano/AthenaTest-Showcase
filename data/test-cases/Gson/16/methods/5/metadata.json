{"identifier": "getRawType", "parameters": "(Type type)", "modifiers": "public static", "return": "Class<?>", "body": "public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }", "class": "Types", "signature": "Class<?> getRawType(Type type)", "full_signature": "public static Class<?> getRawType(Type type)", "class_method_signature": "Types.getRawType(Type type)", "testcase": false, "constructor": false, "invocations": ["getRawType", "checkArgument", "getGenericComponentType", "getClass", "newInstance", "getRawType", "getRawType", "getUpperBounds", "getName", "getClass"]}