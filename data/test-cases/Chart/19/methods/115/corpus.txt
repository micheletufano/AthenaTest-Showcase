CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable { public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } if (state == null) { state = new PlotRenderingInfo(null); } state.setPlotArea(area); RectangleInsets insets = getInsets(); insets.trim(area); AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } boolean foundData = false; Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { int datasetCount = this.datasets.size(); for (int i = 0; i < datasetCount; i++) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); } } for (int i = 0; i < datasetCount; i++) { foundData = render(g2, dataArea, i, state) || foundData; } for (int i = 0; i < datasetCount; i++) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); } } } else { int datasetCount = this.datasets.size(); for (int i = datasetCount - 1; i >= 0; i--) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); } } for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } for (int i = datasetCount - 1; i >= 0; i--) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); } } } for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } drawAnnotations(g2, dataArea, state); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } if (isRangeCrosshairVisible()) { drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } } CategoryPlot(); CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer); String getPlotType(); PlotOrientation getOrientation(); void setOrientation(PlotOrientation orientation); RectangleInsets getAxisOffset(); void setAxisOffset(RectangleInsets offset); CategoryAxis getDomainAxis(); CategoryAxis getDomainAxis(int index); void setDomainAxis(CategoryAxis axis); void setDomainAxis(int index, CategoryAxis axis); void setDomainAxis(int index, CategoryAxis axis, boolean notify); void setDomainAxes(CategoryAxis[] axes); int getDomainAxisIndex(CategoryAxis axis); AxisLocation getDomainAxisLocation(); AxisLocation getDomainAxisLocation(int index); void setDomainAxisLocation(AxisLocation location); void setDomainAxisLocation(AxisLocation location, boolean notify); void setDomainAxisLocation(int index, AxisLocation location); void setDomainAxisLocation(int index, AxisLocation location, boolean notify); RectangleEdge getDomainAxisEdge(); RectangleEdge getDomainAxisEdge(int index); int getDomainAxisCount(); void clearDomainAxes(); void configureDomainAxes(); ValueAxis getRangeAxis(); ValueAxis getRangeAxis(int index); void setRangeAxis(ValueAxis axis); void setRangeAxis(int index, ValueAxis axis); void setRangeAxis(int index, ValueAxis axis, boolean notify); void setRangeAxes(ValueAxis[] axes); int getRangeAxisIndex(ValueAxis axis); AxisLocation getRangeAxisLocation(); AxisLocation getRangeAxisLocation(int index); void setRangeAxisLocation(AxisLocation location); void setRangeAxisLocation(AxisLocation location, boolean notify); void setRangeAxisLocation(int index, AxisLocation location); void setRangeAxisLocation(int index, AxisLocation location, boolean notify); RectangleEdge getRangeAxisEdge(); RectangleEdge getRangeAxisEdge(int index); int getRangeAxisCount(); void clearRangeAxes(); void configureRangeAxes(); CategoryDataset getDataset(); CategoryDataset getDataset(int index); void setDataset(CategoryDataset dataset); void setDataset(int index, CategoryDataset dataset); int getDatasetCount(); void mapDatasetToDomainAxis(int index, int axisIndex); CategoryAxis getDomainAxisForDataset(int index); void mapDatasetToRangeAxis(int index, int axisIndex); ValueAxis getRangeAxisForDataset(int index); CategoryItemRenderer getRenderer(); CategoryItemRenderer getRenderer(int index); void setRenderer(CategoryItemRenderer renderer); void setRenderer(CategoryItemRenderer renderer, boolean notify); void setRenderer(int index, CategoryItemRenderer renderer); void setRenderer(int index, CategoryItemRenderer renderer, boolean notify); void setRenderers(CategoryItemRenderer[] renderers); CategoryItemRenderer getRendererForDataset(CategoryDataset dataset); int getIndexOf(CategoryItemRenderer renderer); DatasetRenderingOrder getDatasetRenderingOrder(); void setDatasetRenderingOrder(DatasetRenderingOrder order); SortOrder getColumnRenderingOrder(); void setColumnRenderingOrder(SortOrder order); SortOrder getRowRenderingOrder(); void setRowRenderingOrder(SortOrder order); boolean isDomainGridlinesVisible(); void setDomainGridlinesVisible(boolean visible); CategoryAnchor getDomainGridlinePosition(); void setDomainGridlinePosition(CategoryAnchor position); Stroke getDomainGridlineStroke(); void setDomainGridlineStroke(Stroke stroke); Paint getDomainGridlinePaint(); void setDomainGridlinePaint(Paint paint); boolean isRangeGridlinesVisible(); void setRangeGridlinesVisible(boolean visible); Stroke getRangeGridlineStroke(); void setRangeGridlineStroke(Stroke stroke); Paint getRangeGridlinePaint(); void setRangeGridlinePaint(Paint paint); LegendItemCollection getFixedLegendItems(); void setFixedLegendItems(LegendItemCollection items); LegendItemCollection getLegendItems(); void handleClick(int x, int y, PlotRenderingInfo info); void zoom(double percent); void datasetChanged(DatasetChangeEvent event); void rendererChanged(RendererChangeEvent event); void addDomainMarker(CategoryMarker marker); void addDomainMarker(CategoryMarker marker, Layer layer); void addDomainMarker(int index, CategoryMarker marker, Layer layer); void clearDomainMarkers(); Collection getDomainMarkers(Layer layer); Collection getDomainMarkers(int index, Layer layer); void clearDomainMarkers(int index); void addRangeMarker(Marker marker); void addRangeMarker(Marker marker, Layer layer); void addRangeMarker(int index, Marker marker, Layer layer); void clearRangeMarkers(); Collection getRangeMarkers(Layer layer); Collection getRangeMarkers(int index, Layer layer); void clearRangeMarkers(int index); boolean isRangeCrosshairVisible(); void setRangeCrosshairVisible(boolean flag); boolean isRangeCrosshairLockedOnData(); void setRangeCrosshairLockedOnData(boolean flag); double getRangeCrosshairValue(); void setRangeCrosshairValue(double value); void setRangeCrosshairValue(double value, boolean notify); Stroke getRangeCrosshairStroke(); void setRangeCrosshairStroke(Stroke stroke); Paint getRangeCrosshairPaint(); void setRangeCrosshairPaint(Paint paint); List getAnnotations(); void addAnnotation(CategoryAnnotation annotation); boolean removeAnnotation(CategoryAnnotation annotation); void clearAnnotations(); void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state); void drawBackground(Graphics2D g2, Rectangle2D area); boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info); Range getDataRange(ValueAxis axis); int getWeight(); void setWeight(int weight); AxisSpace getFixedDomainAxisSpace(); void setFixedDomainAxisSpace(AxisSpace space); AxisSpace getFixedRangeAxisSpace(); void setFixedRangeAxisSpace(AxisSpace space); List getCategories(); List getCategoriesForAxis(CategoryAxis axis); boolean getDrawSharedDomainAxis(); void setDrawSharedDomainAxis(boolean draw); boolean isDomainZoomable(); boolean isRangeZoomable(); void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source); void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source); void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor); void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source); void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor); void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source); double getAnchorValue(); void setAnchorValue(double value); void setAnchorValue(double value, boolean notify); boolean equals(Object obj); Object clone(); static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE; static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE; static final Stroke DEFAULT_GRIDLINE_STROKE; static final Paint DEFAULT_GRIDLINE_PAINT; static final Font DEFAULT_VALUE_LABEL_FONT; static final boolean DEFAULT_CROSSHAIR_VISIBLE; static final Stroke DEFAULT_CROSSHAIR_STROKE; static final Paint DEFAULT_CROSSHAIR_PAINT; }