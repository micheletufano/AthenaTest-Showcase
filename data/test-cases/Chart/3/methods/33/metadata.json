{"identifier": "addOrUpdate", "parameters": "(TimeSeriesDataItem item)", "modifiers": "public", "return": "TimeSeriesDataItem", "body": "public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            // to find the revised minY / maxY\n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  // remove old items if necessary, but\n                                 // don't notify anyone, because that\n                                 // happens next anyway...\n        fireSeriesChanged();\n        return overwritten;\n\n    }", "class": "TimeSeries", "signature": "TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item)", "full_signature": "public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item)", "class_method_signature": "TimeSeries.addOrUpdate(TimeSeriesDataItem item)", "testcase": false, "constructor": false, "invocations": ["getClass", "getPeriod", "equals", "getName", "getName", "binarySearch", "get", "clone", "getValue", "doubleValue", "isNaN", "setValue", "getValue", "findBoundsByIteration", "getValue", "doubleValue", "getValue", "minIgnoreNaN", "minIgnoreNaN", "clone", "add", "updateBoundsForAddedItem", "getItemCount", "remove", "updateBoundsForRemovedItem", "removeAgedItems", "fireSeriesChanged"]}