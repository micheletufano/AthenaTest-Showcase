{"identifier": "findStackedRangeBounds", "parameters": "(CategoryDataset dataset,\n                                               KeyToGroupMap map)", "modifiers": "public static", "return": "Range", "body": "public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }", "class": "DatasetUtilities", "signature": "Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map)", "full_signature": "public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map)", "class_method_signature": "DatasetUtilities.findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map)", "testcase": false, "constructor": false, "invocations": ["getRowCount", "getRowCount", "getGroupIndex", "getGroup", "getRowKey", "getGroupCount", "getColumnCount", "getRowCount", "getValue", "doubleValue", "min", "max", "combine"]}