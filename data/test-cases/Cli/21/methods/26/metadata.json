{"identifier": "process", "parameters": "(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)", "modifiers": "public", "return": "void", "body": "public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (looksLikeOption(commandLine, arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }", "class": "GroupImpl", "signature": "void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)", "full_signature": "public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)", "class_method_signature": "GroupImpl.process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)", "testcase": false, "constructor": false, "invocations": ["hasNext", "next", "previous", "get", "previous", "process", "looksLikeOption", "values", "tailMap", "iterator", "hasNext", "next", "canProcess", "previous", "process", "previous", "previous", "isEmpty", "iterator", "hasNext", "next", "canProcess", "process"]}