GroupImpl extends OptionImpl implements Group { public void validate(final WriteableCommandLine commandLine) throws OptionException { int present = 0; Option unexpected = null; for (final Iterator i = options.iterator(); i.hasNext();) { final Option option = (Option) i.next(); boolean validate = option.isRequired() || option instanceof Group; if (commandLine.hasOption(option)) { if (++present > maximum) { unexpected = option; break; } validate = true; } if (validate) { option.validate(commandLine); } } if (unexpected != null) { throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName()); } if (present < minimum) { throw new OptionException(this, ResourceConstants.MISSING_OPTION); } for (final Iterator i = anonymous.iterator(); i.hasNext();) { final Option option = (Option) i.next(); option.validate(commandLine); } } GroupImpl(final List options, final String name, final String description, final int minimum, final int maximum); boolean canProcess(final WriteableCommandLine commandLine, final String arg); Set getPrefixes(); Set getTriggers(); void process(final WriteableCommandLine commandLine, final ListIterator arguments); void validate(final WriteableCommandLine commandLine); String getPreferredName(); String getDescription(); void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp); void appendUsage(final StringBuffer buffer, final Set helpSettings, final Comparator comp, final String separator); List helpLines(final int depth, final Set helpSettings, final Comparator comp); List getOptions(); List getAnonymous(); Option findOption(final String trigger); int getMinimum(); int getMaximum(); boolean isRequired(); void defaults(final WriteableCommandLine commandLine); }